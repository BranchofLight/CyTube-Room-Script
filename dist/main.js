/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, { enumerable: true, get: getter });
/******/ 		}
/******/ 	};
/******/
/******/ 	// define __esModule on exports
/******/ 	__webpack_require__.r = function(exports) {
/******/ 		if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 			Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 		}
/******/ 		Object.defineProperty(exports, '__esModule', { value: true });
/******/ 	};
/******/
/******/ 	// create a fake namespace object
/******/ 	// mode & 1: value is a module id, require it
/******/ 	// mode & 2: merge all properties of value into the ns
/******/ 	// mode & 4: return value when already ns object
/******/ 	// mode & 8|1: behave like require
/******/ 	__webpack_require__.t = function(value, mode) {
/******/ 		if(mode & 1) value = __webpack_require__(value);
/******/ 		if(mode & 8) return value;
/******/ 		if((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;
/******/ 		var ns = Object.create(null);
/******/ 		__webpack_require__.r(ns);
/******/ 		Object.defineProperty(ns, 'default', { enumerable: true, value: value });
/******/ 		if(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));
/******/ 		return ns;
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = "./src/index.js");
/******/ })
/************************************************************************/
/******/ ({

/***/ "./src/index.js":
/*!**********************!*\
  !*** ./src/index.js ***!
  \**********************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("/**\n * TODO\n * /gif -> giphy search (use a different API?)\n * Integrate webpack for bundling and minifying ONLY (use prettier watch, eslint vscode extension)\n * Break out code into other files (processors, utility, or whatever makes sense)\n * /video -> take lead (if don't already have it), pause video (admin / mod only)\n *        => can I do this with the youtube api directly? or simulate click?\n **/\n\n// gif ideas:\n// -> embed a block that allows you to ask for new gif before committing (ala Slack)\n//    -> use visual notifications of confirmed / not confirmed gifs\n\n// /gif term\n// -> search gif api for term\n// Create way to send \"server\" messages (used for everything)\n// /video\n// -> pauses / play video with lead (admin/mod only)\n// /spin\n// -> spin whatever shows to the right\n// /scroll\n// -> scroll whatever shows to the right\n\nArray.prototype.getLastItem = function () {\n    return this[this.length - 1];\n};\n\nlet newMsgInterval = undefined;\n\nconst userConfig = [\n    {\n        username: \"geoffkeighley\",\n        colour: \"red\",\n    },\n    {\n        username: \"sadweeaboo2\",\n        colour: \"#e6b423\",\n    },\n    {\n        username: \"Fitzthistlewits\",\n        colour: \"#a83fff\",\n    },\n];\n\nconst currentUsername = document\n    .querySelector(\"#welcome\")\n    .innerText.split(\" \")\n    .getLastItem();\n\nconst msgBuffer = document.querySelector(\"#messagebuffer\");\nconst videoBuffer = document.querySelector(\".videolist#queue\");\nconst userList = document.querySelector(\"#userlist\");\n\nconst getServerMsgNode = (msgText, colour) => {\n    const container = document.createElement(\"div\");\n    container.classList.add(\"server-msg-reconnect\");\n    container.innerText = msgText;\n    container.style.color = colour;\n\n    return container;\n};\n\nconst sendUserMsg = node => {};\n\nconst getMediaNode = () => {\n    const container = document.createElement(\"div\");\n    container.classList.add(\"media-container\");\n\n    return container;\n};\n\nconst getImgNode = imgSrc => {\n    const newNode = document.createElement(\"img\");\n    newNode.src = imgSrc;\n    newNode.classList.add(\"image-msg\");\n    newNode.classList.add(\"media-msg\");\n\n    newNode.onclick = () => {\n        document.querySelector(\".image-preview img\").src = imgSrc;\n        document.querySelector(\".image-preview\").classList.remove(\"hidden\");\n    };\n    newNode.onload = scrollMsgBufferToBottom;\n\n    return newNode;\n};\n\nconst getVideoNode = videoSrc => {\n    const newNode = document.createElement(\"video\");\n    newNode.autoplay = true;\n    newNode.controls = true;\n    newNode.poster = true;\n    newNode.loop = true;\n    newNode.muted = true;\n\n    newNode.onloadedmetadata = scrollMsgBufferToBottom;\n    newNode.addEventListener(\"error\", scrollMsgBufferToBottom);\n\n    const srcElement = document.createElement(\"source\");\n    srcElement.src = videoSrc;\n    const fileExt = videoSrc.match(/(?=.)\\w*$/i);\n    srcElement.type = \"video/\" + fileExt;\n\n    newNode.appendChild(srcElement);\n    newNode.classList.add(\"video-msg\");\n    newNode.classList.add(\"media-msg\");\n\n    return newNode;\n};\n\nlet customStyleTag = document.createElement(\"style\");\ncustomStyleTag.classList.add(\"custom-css\");\nconst initCustomCSS = () => {\n    const customCssInHead = document.head.querySelector(\".custom-css\");\n    if (customCssInHead === null) {\n        document.head.appendChild(customStyleTag);\n    } else {\n        customStyleTag = customCssInHead;\n        customStyleTag.innerText = \"\";\n    }\n};\n\nconst addCSS = cssString => {\n    customStyleTag.innerText = customStyleTag.innerText + \" \" + cssString;\n};\n\nconst initCustomUserSettings = () => {\n    const getCustomUserCss = userConfig => {\n        return `\n    .chat-msg-${userConfig.username} .username {\n      color: ${userConfig.colour};\n    }\n    .video-added-by-${userConfig.username} strong {\n      color: ${userConfig.colour};\n    }\n    .username-${userConfig.username} {\n      color: ${userConfig.colour};\n    }\n    `;\n    };\n\n    for (let i = 0; i < userConfig.length; i++) {\n        addCSS(getCustomUserCss(userConfig[i]));\n    }\n\n    addCSS(\n        `\n          .hidden {\n            display: none !important;\n          }\n          .queue_entry > span:first-of-type {\n            margin-left: 5px;\n          }\n          .removed-msg {\n            display: none !important;\n          }\n          .media-container {\n            display: inline-block;\n            overflow: hidden;\n          }\n          .media-msg {\n            max-width: 200px;\n            max-height: 200px;\n          }\n          .image-msg {\n            transition: 0.2s all;\n            cursor: zoom-in;\n          }\n          .image-msg:hover {\n            transform: scale(1.25);\n          }\n          .image-preview {\n            position: fixed;\n            top: 0;\n            left: 0;\n            z-index: 9999;\n\n            width: 100vw;\n            height: 100vh;\n\n            background-color: rgba(0, 0, 0, 0.4);\n\n            display: flex;\n            align-items: center;\n            justify-content: center;\n\n            cursor: zoom-out;\n          }\n          .image-preview img {\n            max-width: 80%;\n            max-height: 80%;\n          }\n     `\n    );\n};\n\nconst isNodeServerMsg = node => {\n    return node.className.includes(\"server-msg\");\n};\n\nconst scrollMsgBufferToBottom = () => {\n    msgBuffer.scrollTop = msgBuffer.scrollHeight;\n};\n\nconst createProcessor = listOfProcessors => {\n    return mutationsList => {\n        for (let mutation of mutationsList) {\n            mutation.addedNodes.forEach(n => {\n                for (let i = 0; i < listOfProcessors.length; i++) {\n                    listOfProcessors[i](n);\n                }\n            });\n        }\n    };\n};\n\n/**\n * Message Processors + Helpers\n **/\n\nconst addUsernameToMsgProcessor = node => {\n    if (!isNodeServerMsg(node) && node.querySelector(\".username\") === null) {\n        const username = node.className.split(\"-\").getLastItem();\n        const usernameNode = document.createElement(\"span\");\n        usernameNode.innerHTML = `<strong class=\"username\">${username}: </strong>`;\n        node.insertBefore(usernameNode, node.querySelector(\"span:last-child\"));\n    }\n};\n\nconst whitelistedActions = [\n    \"/gif\",\n    \"/spin\",\n    \"/scroll\",\n    \"/video\",\n    \"/rave\", // maybe? idk\n];\n\nconst apiConfig = {\n    baseURL: \"api.giphy.com/v1/gifs/search\",\n    apiKey: \"fo4xOJtcZuXE1t6JSoof674hHercv45G\",\n    limit: 25,\n};\n\n// const doesMsgContainWhitelistedAction = msg => {\n//   const msgSplit = msg.split(' ');\n//   for (let i = 0; i < msgSplit.length; i++) {\n//     if (whitelistedActions.includes(msgSplit[i])) {\n//       return true;\n//     }\n//   }\n//\n//   return false;\n// };\n\nconst replaceMsgWithNode = (msgNode, newNode) => {\n    msgNode.parentNode.replaceChild(newNode, msgNode);\n};\n\nconst getGifSelectDialogNode = gifsList => {\n    let gifsListIndex = 0;\n    const container = document.createElement(\"span\");\n    container.classList.add(\"gif-dialog\");\n\n    const nextButton = document.createElement(\"button\");\n    nextButton.classList.add(\"next-button\");\n    nextButton.innerText = \"Next\";\n    nextButton.addEventListener(\"click\", () => {\n        gifsListIndex =\n            gifsListIndex >= gifsList.length - 1 ? 0 : gifsListIndex + 1;\n        container.querySelector(\"img\").src =\n            gifsList[gifsListIndex].images.original.url;\n    });\n\n    const confirmButton = document.createElement(\"button\");\n    confirmButton.classList.add(\"confirm-button\");\n    confirmButton.innerText = \"✓\";\n\n    const cancelButton = document.createElement(\"button\");\n    cancelButton.classList.add(\"cancel-button\");\n    cancelButton.innerText = \"✖\";\n    cancelButton.addEventListener(\"click\", () => container.remove());\n\n    const imgNode = getImgNode(gifsList[0].images.original.url);\n\n    container.appendChild(imgNode);\n    container.appendChild(nextButton);\n    container.appendChild(confirmButton);\n    container.appendChild(cancelButton);\n\n    return container;\n};\n\nconst getGifSelectNode = term => {\n    if (term.length > 0) {\n        fetch(\n            `https://${apiConfig.baseURL}?api_key=${\n                apiConfig.apiKey\n            }&q=${encodeURIComponent(term)}`\n        ).then(res => {\n            if (res.status !== 200) {\n                console.log(\"Server error: \", res.status);\n            } else {\n                res.json()\n                    .then(({ data }) => {\n                        console.log(data);\n                        if (data.length > 0) {\n                            msgBuffer.appendChild(getGifSelectDialogNode(data));\n                            // create node with 3 buttons (next, confirm, cancel)\n                            // insert first gif into it (use getimgnode?)\n                        }\n                    })\n                    .catch(err => {\n                        console.log(\"ERROR: \", err);\n                    });\n            }\n        });\n        // if has results ->\n        // create node with gif inside and 3 buttons ()\n        // if has no results ->\n        // return server error message to only initiating user\n        // everyone else just sees the failed gif search\n        // ->> how do we prevent this causing issues on refresh?\n    }\n};\n\nconst addFeatureNotImplementedNode = action => {\n    const testNode = document.createElement(\"div\");\n    testNode.classList.add(\"gif\");\n    testNode.innerText = \"HELLO \" + action;\n    return testNode;\n};\n\nconst manageInlineEmbedsProcessor = node => {\n    const msgNode = node.querySelector(\":scope > span:last-of-type\");\n    const msgUsername = node.className.split(\"-\").getLastItem();\n\n    if (!isNodeServerMsg(node)) {\n        const message = msgNode.innerText;\n        const action = message.split(\" \")[0];\n\n        if (whitelistedActions.includes(action)) {\n            const startParse = message.lastIndexOf(action);\n            const param = message.slice(startParse + action.length).trim();\n\n            switch (action) {\n                // case \"/gif\":\n                // if (msgUsername === currentUsername) {\n                //     getGifSelectNode(param).then(node => {});\n                // }\n                // break;\n                default:\n                    addFeatureNotImplementedNode(action);\n            }\n        }\n    }\n};\n\nconst doesMsgContainImg = msg => {\n    const urls = msg.match(/.*\\.(?:jpg|gif|png|bmp|jpeg|webp)/i);\n    return urls !== null && urls.length === 1 && urls[0] === msg;\n};\n\nconst doesMsgContainVideo = msg => {\n    const urls = msg.match(/.*\\.(?:webm|mp4)/i);\n    return urls !== null && urls.length === 1 && urls[0] === msg;\n};\n\nconst addImgOrVideoProcessor = node => {\n    const msgNode = node.querySelector(\":scope > span:last-of-type\");\n    if (msgNode !== null && !isNodeServerMsg(node)) {\n        const message = msgNode.innerText;\n        let newNode = undefined;\n\n        if (doesMsgContainImg(message)) {\n            newNode = getImgNode(message);\n        } else if (doesMsgContainVideo(message)) {\n            newNode = getVideoNode(message);\n        }\n\n        if (newNode !== undefined) {\n            const container = getMediaNode();\n            container.appendChild(newNode);\n            replaceMsgWithNode(msgNode, container);\n        }\n    }\n};\n\nconst getVisibilityData = () => {\n    if (typeof document.hidden !== \"undefined\") {\n        return {\n            hidden: \"hidden\",\n            visibilityEvent: \"visibilitychange\",\n        };\n    } else if (typeof document.msHidden !== \"undefined\") {\n        return {\n            hidden: \"msHidden\",\n            visibilityEvent: \"msvisibilitychange\",\n        };\n    } else if (typeof document.webkitHidden !== \"undefined\") {\n        return {\n            hidden: \"webkitHidden\",\n            visibilityEvent: \"webkitvisibilitychange\",\n        };\n    }\n\n    return undefined;\n};\n\nconst newMsgTabAlertProcessor = () => {\n    const visiblityData = getVisibilityData();\n    if (\n        visiblityData &&\n        document[visiblityData.hidden] &&\n        newMsgInterval === undefined\n    ) {\n        newMsgInterval = setInterval(() => {\n            if (document.title === \"geoffkeighleysroom\") {\n                document.title = \"New Message!\";\n            } else {\n                document.title = \"geoffkeighleysroom\";\n            }\n        }, 500);\n    }\n};\n\n/**\n * Video Playlist Processors\n **/\nconst addUsernameToVideoProcessor = node => {\n    if (node.querySelector('span[class*=\"video-added-by\"]') === null) {\n        const username = node.title.split(\" \").getLastItem();\n        const nameSpan = document.createElement(\"span\");\n        nameSpan.className = `video-added-by-${username}`;\n        nameSpan.innerHTML = `Added by <strong>${username}</strong>`;\n        node.insertBefore(nameSpan, node.querySelector(\"span\"));\n    }\n};\n\n/**\n * User List Processors\n **/\nconst addClassToUserlistProcessor = node => {\n    if (node.querySelector('[class*=\"username-\"]') === null) {\n        const userNode = node.querySelector(\":scope > span:last-of-type\");\n        userNode.className = `username-${userNode.innerText}`;\n    }\n};\n\nconst addObserverToUserProcessor = outerNode => {\n    const userChangeProcessor = innerNode => {\n        const parent = innerNode.parentNode.parentNode;\n        const userNode = parent.querySelector(\":scope > span:last-of-type\");\n        if (parent.querySelector('[class*=\"username-\"]') === null) {\n            userNode.className = `username-${userNode.innerText}`;\n        }\n    };\n\n    const userObserver = new MutationObserver(\n        createProcessor([userChangeProcessor])\n    );\n\n    outerNode = outerNode.querySelector(\"span\");\n    userObserver.observe(outerNode, { childList: true });\n};\n\nconst orderedMsgProcessors = [\n    addUsernameToMsgProcessor,\n    manageInlineEmbedsProcessor,\n    newMsgTabAlertProcessor,\n    addImgOrVideoProcessor,\n    scrollMsgBufferToBottom,\n];\n\nconst orderedVideoProcessors = [addUsernameToVideoProcessor];\n\nconst orderedUserlistProcessors = [\n    addClassToUserlistProcessor,\n    addObserverToUserProcessor,\n];\n\nconst runAllProcessors = () => {\n    msgBuffer.childNodes.forEach(n => {\n        for (let i = 0; i < orderedMsgProcessors.length; i++) {\n            orderedMsgProcessors[i](n);\n        }\n    });\n\n    videoBuffer.childNodes.forEach(n => {\n        for (let i = 0; i < orderedVideoProcessors.length; i++) {\n            orderedVideoProcessors[i](n);\n        }\n    });\n\n    userList.childNodes.forEach(n => {\n        for (let i = 0; i < orderedUserlistProcessors.length; i++) {\n            orderedUserlistProcessors[i](n);\n        }\n    });\n};\n\nconst initVisibilityListener = () => {\n    const visiblityData = getVisibilityData();\n    if (visiblityData !== undefined) {\n        document.addEventListener(visiblityData.visibilityEvent, () => {\n            if (!document[visiblityData.hidden] && newMsgInterval) {\n                clearInterval(newMsgInterval);\n                newMsgInterval = undefined;\n                document.title = \"geoffkeighleysroom\";\n            }\n        });\n    }\n};\n\n// eslint-disable-next-line no-unused-vars\nconst initScript = (() => {\n    initCustomCSS();\n    initCustomUserSettings();\n\n    runAllProcessors();\n\n    initVisibilityListener();\n\n    const msgObserver = new MutationObserver(\n        createProcessor(orderedMsgProcessors)\n    );\n    const videoObserver = new MutationObserver(\n        createProcessor(orderedVideoProcessors)\n    );\n    const userlistObserver = new MutationObserver(\n        createProcessor(orderedUserlistProcessors)\n    );\n\n    msgObserver.observe(msgBuffer, { childList: true });\n    videoObserver.observe(videoBuffer, { childList: true });\n    userlistObserver.observe(userList, { childList: true });\n\n    // eslint-disable-next-line no-unused-vars\n    const initLargeImageArea = (() => {\n        const imgPreviewClass = \"image-preview\";\n        if (document.querySelector(`.${imgPreviewClass}`) === null) {\n            const imgPreviewContainer = document.createElement(\"div\");\n            imgPreviewContainer.classList.add(imgPreviewClass);\n            imgPreviewContainer.classList.add(\"hidden\");\n            imgPreviewContainer.onclick = () => {\n                imgPreviewContainer.classList.add(\"hidden\");\n            };\n\n            const previewImage = document.createElement(\"img\");\n            imgPreviewContainer.appendChild(previewImage);\n\n            document.addEventListener(\"keydown\", e => {\n                if (\n                    e.key === \"Escape\" &&\n                    !imgPreviewContainer.classList.contains(\"hidden\")\n                ) {\n                    imgPreviewContainer.classList.add(\"hidden\");\n                }\n            });\n\n            document.body.appendChild(imgPreviewContainer);\n        }\n    })();\n})();\n\n\n//# sourceURL=webpack:///./src/index.js?");

/***/ })

/******/ });